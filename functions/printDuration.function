#!/usr/bin/env bash
#
# Internal function: Print the last recorded duration of scriptName if one is found.
#
# Duration files are tab separated -- used to record script durations for predictions and stats
#
#     Script Name         Timestamp              Date String             Duration
# generateXrefData.sh   201210.202416   Thu Dec 10 20:24:16 PST 2020    16 seconds.
#
# Timestamp and Date String are the same time, Timestamp for sorting. Date String for humans.

function printDuration() {
    local OPTIND scriptName

    help() {
        cat <<EOF
printDuration -- Internal function: Print the last duration of \$0 found in .xref_durations

.xref_durations is read by printDuration to inform the user of the predicted
duration of a long running process, .e.g. downloading all IMDb .gz files.

USAGE:
    printDuration [OPTIONS...]

OPTIONS:
    -h      Print this message.

EXAMPLES:
    printDuration

EOF
    }

    while getopts ":h" opt; do
        case $opt in
        h)
            help
            read -n 1 -s -p "Hit any key to continue, '^C' to quit. "
            printf "\n"
            return
            ;;
        \?)
            printf "==> [${YELLOW}Warning${NO_COLOR}] Ignoring invalid " >&2
            printf "${YELLOW}-$OPTARG${NO_COLOR} option in: ${YELLOW}$0${NO_COLOR}\n" >&2
            ;;
        :)
            printf "==> [${RED}Error${NO_COLOR}] Option ${RED}-$OPTARG${NO_COLOR}" >&2
            printf "in: ${RED}$0${NO_COLOR} requires an argument.'\n\n" >&2
            exit 1
            ;;
        esac
    done
    shift $((OPTIND - 1))

    scriptName="$(basename $0)"

    if [ $(rg -c "^$scriptName\t" $durationFile) ]; then
        printf "\n==> Previously, this took "
        rg "^$scriptName\t" $durationFile | tail -1 | cut -f 4
        printf "\n"
    fi
}
