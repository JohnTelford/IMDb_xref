#!/usr/bin/env bash
#
# This is a general-purpose function to ask Yes/No questions in Bash, or simply
# wait for any keystroke. It takes an optional prompt string.
#
# Y or N questions can set a default. It keeps repeating the question until it
# gets a valid answer.
#
# Normally it reads a single character and looks for y, Y, n, N, or <cr>
#
# With the -l switch, it also accepts longer answers, e.g. "yes" or "no" followed by <cr>
# Surprisingly "yellow" will also work as only the first character is checked.

function ask_YN() {
    local OPTIND clearScreenP longRead yesno default anyKey reply

    help() {
        cat <<EOF
ask_YN -- ask Yes/No questions, or wait for any key, with an optional prompt

USAGE:
    ask_YN [OPTIONS...] [PROMPT_STRING]

OPTIONS:
    -h      Print this message.
    -c      Clear screen before prompting.
    -l      Allow longer answer, like "yes" or "no" followed by <cr>
    -N      Default to N if a <cr> is the first character typed.
    -Y      Default to Y if a <cr> is the first character typed.
    -w      Wait for any keystroke. Overrides -l switch.

EOF
    }

    while getopts ":hclNYw" opt; do
        case $opt in
        h)
            help
            read -n 1 -s -p "Hit any key to continue, '^C' to quit. "
            printf "\n"
            return
            ;;
        c)
            clearScreenP="yes"
            ;;
        l)
            longRead="yes"
            ;;
        N)
            yesno="[y/N] "
            default="N"
            ;;
        Y)
            yesno="[Y/n] "
            default="Y"
            ;;
        w)
            anyKey="yes"
            ;;
        \?)
            printf "==> [${YELLOW}Warning${NO_COLOR}] Ignoring invalid " >&2
            printf "${YELLOW}-$OPTARG${NO_COLOR} option in: ${YELLOW}$0${NO_COLOR}\n" >&2
            ;;
        :)
            printf "Option -$OPTARG requires an argument'.\n\n" >&2
            exit 1
            ;;
        esac
    done
    shift $((OPTIND - 1))

    # If we only want to wait for a key to be hit...
    if [ -n "$anyKey" ]; then
        printf "\n"
        [ -n "$clearScreenP" ] && clear
        read -n 1 -s -p "${1:-Hit any key to continue, '^C' to quit.} " </dev/tty
        printf "\n\n"
        return
    fi

    # Now we want a yes or no answer...
    [ -z "$yesno" ] && yesno="[y/n] "

    while true; do
        # Ask the question (not using "read -p" as it uses stderr not stdout)
        [ -n "$clearScreenP" ] && clear
        printf "${1:-Does that look correct?} $yesno"
        #
        # Read the answer (use /dev/tty in case stdin is redirected from somewhere else)
        if [ -n "$longRead" ]; then
            read reply </dev/tty
        else
            read -n 1 -s reply </dev/tty
            [ -z "$reply" ] || [ "${#reply}" != 0 ] && printf "\n"
        fi
        #
        # If no reply, use the default if it exists
        if [ -z "$reply" ]; then
            reply="$default"
        fi
        #
        case "$reply" in
        Y* | y*)
            return 0
            ;;
        N* | n*)
            return 1
            ;;
        esac
    done
}
